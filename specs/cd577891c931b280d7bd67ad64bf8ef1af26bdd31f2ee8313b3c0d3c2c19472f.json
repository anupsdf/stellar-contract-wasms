[
  {
    "udt_union_v0": {
      "doc": "",
      "lib": "",
      "name": "RolesDataKey",
      "cases": [
        {
          "void_v0": {
            "doc": "",
            "name": "EmergencyManager"
          }
        },
        {
          "void_v0": {
            "doc": "",
            "name": "VaultFeeReceiver"
          }
        },
        {
          "void_v0": {
            "doc": "",
            "name": "Manager"
          }
        },
        {
          "void_v0": {
            "doc": "",
            "name": "RebalanceManager"
          }
        }
      ]
    }
  },
  {
    "udt_error_enum_v0": {
      "doc": "",
      "lib": "",
      "name": "ContractError",
      "cases": [
        {
          "doc": "",
          "name": "NotInitialized",
          "value": 100
        },
        {
          "doc": "",
          "name": "InvalidRatio",
          "value": 101
        },
        {
          "doc": "",
          "name": "StrategyDoesNotSupportAsset",
          "value": 102
        },
        {
          "doc": "",
          "name": "NoAssetAllocation",
          "value": 103
        },
        {
          "doc": "",
          "name": "RolesIncomplete",
          "value": 104
        },
        {
          "doc": "",
          "name": "MetadataIncomplete",
          "value": 105
        },
        {
          "doc": "",
          "name": "MaximumFeeExceeded",
          "value": 106
        },
        {
          "doc": "",
          "name": "DuplicatedAsset",
          "value": 107
        },
        {
          "doc": "",
          "name": "DuplicatedStrategy",
          "value": 108
        },
        {
          "doc": "",
          "name": "AmountNotAllowed",
          "value": 110
        },
        {
          "doc": "",
          "name": "InsufficientBalance",
          "value": 111
        },
        {
          "doc": "",
          "name": "WrongAmountsLength",
          "value": 112
        },
        {
          "doc": "",
          "name": "WrongLockedFees",
          "value": 113
        },
        {
          "doc": "",
          "name": "InsufficientManagedFunds",
          "value": 114
        },
        {
          "doc": "",
          "name": "MissingInstructionData",
          "value": 115
        },
        {
          "doc": "",
          "name": "UnsupportedAsset",
          "value": 116
        },
        {
          "doc": "",
          "name": "InsufficientAmount",
          "value": 117
        },
        {
          "doc": "",
          "name": "NoOptimalAmounts",
          "value": 118
        },
        {
          "doc": "",
          "name": "WrongInvestmentLength",
          "value": 119
        },
        {
          "doc": "",
          "name": "WrongAssetAddress",
          "value": 122
        },
        {
          "doc": "",
          "name": "WrongStrategiesLength",
          "value": 123
        },
        {
          "doc": "",
          "name": "AmountOverTotalSupply",
          "value": 124
        },
        {
          "doc": "",
          "name": "NoInstructions",
          "value": 125
        },
        {
          "doc": "",
          "name": "NotUpgradable",
          "value": 126
        },
        {
          "doc": "",
          "name": "UnwindMoreThanAvailable",
          "value": 128
        },
        {
          "doc": "",
          "name": "InsufficientFeesToRelease",
          "value": 129
        },
        {
          "doc": "",
          "name": "ArithmeticError",
          "value": 120
        },
        {
          "doc": "",
          "name": "Overflow",
          "value": 121
        },
        {
          "doc": "",
          "name": "Underflow",
          "value": 127
        },
        {
          "doc": "",
          "name": "Unauthorized",
          "value": 130
        },
        {
          "doc": "",
          "name": "RoleNotFound",
          "value": 131
        },
        {
          "doc": "",
          "name": "ManagerNotInQueue",
          "value": 132
        },
        {
          "doc": "",
          "name": "SetManagerBeforeTime",
          "value": 133
        },
        {
          "doc": "",
          "name": "QueueEmpty",
          "value": 134
        },
        {
          "doc": "",
          "name": "StrategyNotFound",
          "value": 140
        },
        {
          "doc": "",
          "name": "StrategyPausedOrNotFound",
          "value": 141
        },
        {
          "doc": "",
          "name": "StrategyWithdrawError",
          "value": 142
        },
        {
          "doc": "",
          "name": "StrategyInvestError",
          "value": 143
        },
        {
          "doc": "",
          "name": "StrategyPaused",
          "value": 144
        },
        {
          "doc": "",
          "name": "AssetNotFound",
          "value": 150
        },
        {
          "doc": "",
          "name": "NoAssetsProvided",
          "value": 151
        },
        {
          "doc": "",
          "name": "InsufficientOutputAmount",
          "value": 160
        },
        {
          "doc": "",
          "name": "ExcessiveInputAmount",
          "value": 161
        },
        {
          "doc": "",
          "name": "InvalidFeeBps",
          "value": 162
        },
        {
          "doc": "",
          "name": "LibrarySortIdenticalTokens",
          "value": 190
        },
        {
          "doc": "",
          "name": "SoroswapRouterError",
          "value": 200
        },
        {
          "doc": "",
          "name": "SwapExactInError",
          "value": 201
        },
        {
          "doc": "",
          "name": "SwapExactOutError",
          "value": 202
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "VaultDepositEvent",
      "fields": [
        {
          "doc": "",
          "name": "amounts",
          "type_": {
            "vec": {
              "element_type": "i128"
            }
          }
        },
        {
          "doc": "",
          "name": "depositor",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "df_tokens_minted",
          "type_": "i128"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "VaultWithdrawEvent",
      "fields": [
        {
          "doc": "",
          "name": "amounts_withdrawn",
          "type_": {
            "vec": {
              "element_type": "i128"
            }
          }
        },
        {
          "doc": "",
          "name": "df_tokens_burned",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "withdrawer",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "EmergencyWithdrawEvent",
      "fields": [
        {
          "doc": "",
          "name": "amount_withdrawn",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "StrategyPausedEvent",
      "fields": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "StrategyUnpausedEvent",
      "fields": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "FeeReceiverChangedEvent",
      "fields": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "new_fee_receiver",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "ManagerChangedEvent",
      "fields": [
        {
          "doc": "",
          "name": "new_manager",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "EmergencyManagerChangedEvent",
      "fields": [
        {
          "doc": "",
          "name": "new_emergency_manager",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "RebalanceManagerChangedEvent",
      "fields": [
        {
          "doc": "",
          "name": "new_rebalance_manager",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "FeesDistributedEvent",
      "fields": [
        {
          "doc": "",
          "name": "distributed_fees",
          "type_": {
            "vec": {
              "element_type": {
                "tuple": {
                  "value_types": [
                    "address",
                    "i128"
                  ]
                }
              }
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "UnwindEvent",
      "fields": [
        {
          "doc": "",
          "name": "call_params",
          "type_": {
            "vec": {
              "element_type": {
                "tuple": {
                  "value_types": [
                    "address",
                    "i128",
                    "address"
                  ]
                }
              }
            }
          }
        },
        {
          "doc": "",
          "name": "rebalance_method",
          "type_": "symbol"
        },
        {
          "doc": "",
          "name": "report",
          "type_": {
            "udt": {
              "name": "Report"
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "InvestEvent",
      "fields": [
        {
          "doc": "",
          "name": "asset_investments",
          "type_": {
            "vec": {
              "element_type": {
                "udt": {
                  "name": "AssetInvestmentAllocation"
                }
              }
            }
          }
        },
        {
          "doc": "",
          "name": "rebalance_method",
          "type_": "symbol"
        },
        {
          "doc": "",
          "name": "report",
          "type_": {
            "udt": {
              "name": "Report"
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "SwapExactInEvent",
      "fields": [
        {
          "doc": "",
          "name": "rebalance_method",
          "type_": "symbol"
        },
        {
          "doc": "",
          "name": "swap_args",
          "type_": {
            "vec": {
              "element_type": "val"
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "SwapExactOutEvent",
      "fields": [
        {
          "doc": "",
          "name": "rebalance_method",
          "type_": "symbol"
        },
        {
          "doc": "",
          "name": "swap_args",
          "type_": {
            "vec": {
              "element_type": "val"
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "StrategyAllocation",
      "fields": [
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "paused",
          "type_": "bool"
        },
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "CurrentAssetInvestmentAllocation",
      "fields": [
        {
          "doc": "",
          "name": "asset",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "idle_amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "invested_amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "strategy_allocations",
          "type_": {
            "vec": {
              "element_type": {
                "udt": {
                  "name": "StrategyAllocation"
                }
              }
            }
          }
        },
        {
          "doc": "",
          "name": "total_amount",
          "type_": "i128"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "AssetInvestmentAllocation",
      "fields": [
        {
          "doc": "",
          "name": "asset",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "strategy_allocations",
          "type_": {
            "vec": {
              "element_type": {
                "option": {
                  "value_type": {
                    "udt": {
                      "name": "StrategyAllocation"
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  {
    "udt_union_v0": {
      "doc": "",
      "lib": "",
      "name": "Instruction",
      "cases": [
        {
          "tuple_v0": {
            "doc": "Withdraw funds from a strategy.",
            "name": "Unwind",
            "type_": [
              "address",
              "i128"
            ]
          }
        },
        {
          "tuple_v0": {
            "doc": "Invest funds into a strategy.",
            "name": "Invest",
            "type_": [
              "address",
              "i128"
            ]
          }
        },
        {
          "tuple_v0": {
            "doc": "Perform a swap with an exact input amount.",
            "name": "SwapExactIn",
            "type_": [
              "address",
              "address",
              "i128",
              "i128",
              "u64"
            ]
          }
        },
        {
          "tuple_v0": {
            "doc": "Perform a swap with an exact output amount.",
            "name": "SwapExactOut",
            "type_": [
              "address",
              "address",
              "i128",
              "i128",
              "u64"
            ]
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "Report",
      "fields": [
        {
          "doc": "",
          "name": "gains_or_losses",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "locked_fee",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "prev_balance",
          "type_": "i128"
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "total_supply",
      "inputs": [],
      "outputs": [
        "i128"
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "allowance",
      "inputs": [
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "spender",
          "type_": "address"
        }
      ],
      "outputs": [
        "i128"
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "approve",
      "inputs": [
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "spender",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "expiration_ledger",
          "type_": "u32"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "balance",
      "inputs": [
        {
          "doc": "",
          "name": "id",
          "type_": "address"
        }
      ],
      "outputs": [
        "i128"
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "transfer",
      "inputs": [
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "to",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "transfer_from",
      "inputs": [
        {
          "doc": "",
          "name": "spender",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "to",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "burn",
      "inputs": [
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "burn_from",
      "inputs": [
        {
          "doc": "",
          "name": "spender",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "decimals",
      "inputs": [],
      "outputs": [
        "u32"
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "name",
      "inputs": [],
      "outputs": [
        "string"
      ]
    }
  },
  {
    "function_v0": {
      "doc": "",
      "name": "symbol",
      "inputs": [],
      "outputs": [
        "string"
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "AllowanceDataKey",
      "fields": [
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "spender",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "AllowanceValue",
      "fields": [
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "expiration_ledger",
          "type_": "u32"
        }
      ]
    }
  },
  {
    "udt_union_v0": {
      "doc": "",
      "lib": "",
      "name": "DataKey",
      "cases": [
        {
          "tuple_v0": {
            "doc": "",
            "name": "Allowance",
            "type_": [
              {
                "udt": {
                  "name": "AllowanceDataKey"
                }
              }
            ]
          }
        },
        {
          "tuple_v0": {
            "doc": "",
            "name": "Balance",
            "type_": [
              "address"
            ]
          }
        },
        {
          "void_v0": {
            "doc": "",
            "name": "TotalSupply"
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Initializes the DeFindex Vault contract with the required parameters.\\n\\n# Arguments\\n* `e` - The environment reference.\\n* `assets` - List of asset allocations for the vault, including strategies for each asset.\\n* `roles` - Map of role IDs to addresses containing:\\n- Emergency Manager: For emergency control\\n- Vault Fee Receiver: For receiving vault fees\\n- Manager: For primary vault control\\n- Rebalance Manager: For rebalancing operations\\n* `vault_fee` - Vault-specific fee in basis points (0_2000 for 0.20%)\\n* `defindex_protocol_receiver` - Address receiving protocol fees\\n* `defindex_protocol_rate` - Protocol fee rate in basis points (0-9000 for 0-90%)\\n* `soroswap_router` - Soroswap router address\\n* `name_symbol` - Map containing:\\n- \"name\": Vault token name\\n- \"symbol\": Vault token symbol\\n* `upgradable` - Boolean flag for contract upgradeability\\n\\n# Function Flow\\n1. **Role Assignment**:\\n- Sets Emergency Manager\\n- Sets Vault Fee Receiver\\n- Sets Manager\\n- Sets Rebalance Manager\\n\\n2. **Fee Configuration**:\\n- Sets vault fe",
      "name": "__constructor",
      "inputs": [
        {
          "doc": "",
          "name": "assets",
          "type_": {
            "vec": {
              "element_type": {
                "udt": {
                  "name": "AssetStrategySet"
                }
              }
            }
          }
        },
        {
          "doc": "",
          "name": "roles",
          "type_": {
            "map": {
              "key_type": "u32",
              "value_type": "address"
            }
          }
        },
        {
          "doc": "",
          "name": "vault_fee",
          "type_": "u32"
        },
        {
          "doc": "",
          "name": "defindex_protocol_receiver",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "defindex_protocol_rate",
          "type_": "u32"
        },
        {
          "doc": "",
          "name": "soroswap_router",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "name_symbol",
          "type_": {
            "map": {
              "key_type": "string",
              "value_type": "string"
            }
          }
        },
        {
          "doc": "",
          "name": "upgradable",
          "type_": "bool"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "Handles user deposits into the DeFindex Vault and optionally allocates investments automatically.\\n\\nThis function processes a deposit by transferring each specified asset amount from the user's address to\\nthe vault and mints vault shares that represent the user's proportional share in the vault. Additionally,\\nif the `invest` parameter is set to `true`, the function will immediately generate and execute investment\\nallocations based on the vault's strategy configuration.\\n\\n# Parameters\\n* `e` - The current environment reference (`Env`), for access to the contract state and utilities.\\n* `amounts_desired` - A vector specifying the user's intended deposit amounts for each asset.\\n* `amounts_min` - A vector of minimum deposit amounts required for the transaction to proceed.\\n* `from` - The address of the user making the deposit.\\n* `invest` - A boolean flag indicating whether to immediately invest the deposited funds into the vault's strategies:\\n- `true`: Generate and execute investments after the deposit.\\n- `false`: Lea",
      "name": "deposit",
      "inputs": [
        {
          "doc": "",
          "name": "amounts_desired",
          "type_": {
            "vec": {
              "element_type": "i128"
            }
          }
        },
        {
          "doc": "",
          "name": "amounts_min",
          "type_": {
            "vec": {
              "element_type": "i128"
            }
          }
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "invest",
          "type_": "bool"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": [
                  {
                    "vec": {
                      "element_type": "i128"
                    }
                  },
                  "i128",
                  {
                    "option": {
                      "value_type": {
                        "vec": {
                          "element_type": {
                            "option": {
                              "value_type": {
                                "udt": {
                                  "name": "AssetInvestmentAllocation"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                ]
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Handles user withdrawals from the DeFindex Vault by burning shares and returning assets.\\n\\nThis function processes a withdrawal request by burning the specified amount of vault shares\\nand returning a proportional amount of the vault's assets to the user. It can unwind positions\\nfrom strategies if necessary to fulfill the withdrawal.\\n\\n## Parameters:\\n- `e`: The contract environment (`Env`).\\n- `withdraw_shares`: The number of vault shares to withdraw.\\n- `min_amounts_out`: A vector of minimum amounts required for each asset to be withdrawn.\\n- `from`: The address initiating the withdrawal.\\n\\n## Returns\\n* `Result<Vec<i128>, ContractError>` - On success, returns a vector of withdrawn amounts\\nwhere each index corresponds to the asset index in the vault's asset list.\\nReturns ContractError if the withdrawal fails.\\n\\n## Errors:\\n- `ContractError::AmountOverTotalSupply`: If the specified shares exceed the total supply.\\n- `ContractError::ArithmeticError`: If any arithmetic operation fails during calculations.\\n- `ContractError",
      "name": "withdraw",
      "inputs": [
        {
          "doc": "",
          "name": "withdraw_shares",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "min_amounts_out",
          "type_": {
            "vec": {
              "element_type": "i128"
            }
          }
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": "i128"
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Executes rescue (formerly emergency withdrawal) from a specific strategy.\\n\\nThis function allows the emergency manager or manager to withdraw all assets from a particular strategy\\nand store them as idle funds within the vault. It also pauses the strategy to prevent further use until\\nunpaused.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `strategy_address` - The address of the strategy to withdraw from.\\n* `caller` - The address initiating the emergency withdrawal (must be the manager or emergency manager).\\n\\n# Returns\\n* `Result<(), ContractError>` - Success (()) or ContractError if the rescue operation fails",
      "name": "rescue",
      "inputs": [
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Pauses a strategy to prevent it from being used in the vault.\\n\\nThis function pauses a strategy by setting its `paused` field to `true`. Only the manager or emergency\\nmanager can pause a strategy.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `strategy_address` - The address of the strategy to pause.\\n* `caller` - The address initiating the pause (must be the manager or emergency manager).\\n\\n# Returns\\n* `Result<(), ContractError>` - Success (()) or ContractError if the pause operation fails",
      "name": "pause_strategy",
      "inputs": [
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Unpauses a previously paused strategy.\\n\\nThis function unpauses a strategy by setting its `paused` field to `false`, allowing it to be used\\nagain in the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `strategy_address` - The address of the strategy to unpause.\\n* `caller` - The address initiating the unpause (must be the manager or emergency manager).\\n\\n# Returns:\\n* `Result<(), ContractError>` - Ok if successful, otherwise returns a ContractError.",
      "name": "unpause_strategy",
      "inputs": [
        {
          "doc": "",
          "name": "strategy_address",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the list of assets managed by the DeFindex Vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Vec<AssetStrategySet>` - A vector of `AssetStrategySet` structs representing the assets managed by the vault.",
      "name": "get_assets",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": {
                  "udt": {
                    "name": "AssetStrategySet"
                  }
                }
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Returns the total managed funds of the vault, including both invested and idle funds.\\n\\nThis function provides a vector of `CurrentAssetInvestmentAllocation` structs containing information\\nabout each asset's current allocation, including both invested amounts in strategies and idle amounts.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Result<Vec<CurrentAssetInvestmentAllocation>, ContractError>` - A vector of asset allocations or error",
      "name": "fetch_total_managed_funds",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": {
                  "udt": {
                    "name": "CurrentAssetInvestmentAllocation"
                  }
                }
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "This function extends the contract's time-to-live and calculates how much of each asset corresponds\\nper the provided number of vault shares (`vault_shares`). It provides proportional allocations for each asset\\nin the vault relative to the specified shares.\\n\\n# Arguments\\n* `e` - The current environment reference.\\n* `vault_shares` - The number of vault shares for which the corresponding asset amounts are calculated.\\n\\n# Returns\\n* `Result<Vec<i128>, ContractError>` - A vector of asset amounts corresponding to the vault shares, where each index\\nmatches the asset index in the vault's asset list. Returns ContractError if calculation fails.",
      "name": "get_asset_amounts_per_shares",
      "inputs": [
        {
          "doc": "",
          "name": "vault_shares",
          "type_": "i128"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": "i128"
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the current fee rates for the vault and the DeFindex protocol.\\n\\nThis function returns the fee rates for both the vault and the DeFindex protocol.\\n\\n# Arguments\\n* `e` - The environment.\\n\\n# Returns\\n* `(u32, u32)` - A tuple containing:\\n- The vault fee rate as a percentage in basis points.\\n- The DeFindex protocol fee rate as a percentage in basis points.\\n",
      "name": "get_fees",
      "inputs": [],
      "outputs": [
        {
          "tuple": {
            "value_types": [
              "u32",
              "u32"
            ]
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Generates reports for all strategies in the vault, tracking their performance and fee accrual.\\n\\nThis function iterates through all assets and their associated strategies to generate\\nperformance reports. It updates each strategy's report with current balances and\\ncalculates gains or losses since the last report.\\n\\n# Arguments\\n* `e` - The environment reference.\\n\\n# Function Flow\\n1. **Instance Extension**:\\n- Extends contract TTL\\n\\n2. **Asset & Strategy Retrieval**:\\n- Gets all assets and their strategies\\n- Initializes reports vector\\n\\n3. **Report Generation**:\\n- For each asset:\\n- For each strategy:\\n- Gets current strategy balance\\n- Updates report with new balance\\n- Stores updated report\\n\\n# Returns\\n* `Result<Vec<Report>, ContractError>` - On success, returns a vector of reports\\nwhere each report contains performance metrics for a strategy. Returns\\nContractError if report generation fails.\\n\\n# Note\\nReports track:\\n- Current strategy balance\\n- Gains or losses since last report\\n- Locked fees\\n- Fee distribution status",
      "name": "report",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": {
                  "udt": {
                    "name": "Report"
                  }
                }
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Sets the fee receiver for the vault.\\n\\nThis function allows the manager or the vault fee receiver to set a new fee receiver address for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `caller` - The address initiating the change (must be the manager or the vault fee receiver).\\n* `vault_fee_receiver` - The new fee receiver address.\\n\\n# Returns:\\n* `()` - No return value.",
      "name": "set_fee_receiver",
      "inputs": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "new_fee_receiver",
          "type_": "address"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the current fee receiver address for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Result<Address, ContractError>` - The fee receiver address if successful, otherwise returns a ContractError.",
      "name": "get_fee_receiver",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": "address",
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Sets the manager for the vault.\\n\\nThis function allows the current manager to set a new manager for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `new_manager` - The new manager address.\\n\\n# Returns\\n* `Result<(), ContractError>` - Success (()) or ContractError if the manager change fails",
      "name": "set_manager",
      "inputs": [
        {
          "doc": "",
          "name": "new_manager",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the current manager address for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Result<Address, ContractError>` - The manager address if successful, otherwise returns a ContractError.",
      "name": "get_manager",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": "address",
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Sets the emergency manager for the vault.\\n\\nThis function allows the current manager to set a new emergency manager for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `emergency_manager` - The new emergency manager address.\\n\\n# Returns:\\n* `()` - No return value.",
      "name": "set_emergency_manager",
      "inputs": [
        {
          "doc": "",
          "name": "emergency_manager",
          "type_": "address"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the current emergency manager address for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Result<Address, ContractError>` - The emergency manager address if successful, otherwise returns a ContractError.",
      "name": "get_emergency_manager",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": "address",
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Sets the rebalance manager for the vault.\\n\\nThis function allows the current manager to set a new rebalance manager for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `new_rebalance_manager` - The new rebalance manager address.\\n\\n# Returns:\\n* `()` - No return value.",
      "name": "set_rebalance_manager",
      "inputs": [
        {
          "doc": "",
          "name": "new_rebalance_manager",
          "type_": "address"
        }
      ],
      "outputs": []
    }
  },
  {
    "function_v0": {
      "doc": "Retrieves the current rebalance manager address for the vault.\\n\\n# Arguments:\\n* `e` - The environment.\\n\\n# Returns:\\n* `Result<Address, ContractError>` - The rebalance manager address if successful, otherwise returns a ContractError.",
      "name": "get_rebalance_manager",
      "inputs": [],
      "outputs": [
        {
          "result": {
            "ok_type": "address",
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Upgrades the contract with new WebAssembly (WASM) code.\\n\\nThis function updates the contract with new WASM code provided by the `new_wasm_hash`.\\n\\n# Arguments\\n\\n* `e` - The runtime environment.\\n* `new_wasm_hash` - The hash of the new WASM code to upgrade the contract to.\\n\\n# Returns\\n* `Result<(), ContractError>` - Returns Ok(()) on success, ContractError if upgrade fails\\n",
      "name": "upgrade",
      "inputs": [
        {
          "doc": "",
          "name": "new_wasm_hash",
          "type_": {
            "bytes_n": {
              "n": 32
            }
          }
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Rebalances the vault by executing a series of instructions.\\n\\n# Arguments:\\n* `e` - The environment.\\n* `instructions` - A vector of `Instruction` structs representing actions (withdraw, invest, swap, zapper) to be taken.\\n\\n# Returns:\\n* `Result<(), ContractError>` - Ok if successful, otherwise returns a ContractError.",
      "name": "rebalance",
      "inputs": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "instructions",
          "type_": {
            "vec": {
              "element_type": {
                "udt": {
                  "name": "Instruction"
                }
              }
            }
          }
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": []
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Locks fees for all assets and their strategies.\\n\\nIterates through each asset and its strategies, locking fees based on `new_fee_bps` or the default vault fee.\\n\\n# Arguments\\n* `e` - The environment reference.\\n* `new_fee_bps` - Optional fee basis points to override the default.\\n\\n# Returns\\n* `Result<Vec<(Address, i128)>, ContractError>` - A vector of tuples with strategy addresses and locked fee amounts in their underlying_asset.",
      "name": "lock_fees",
      "inputs": [
        {
          "doc": "",
          "name": "new_fee_bps",
          "type_": {
            "option": {
              "value_type": "u32"
            }
          }
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": {
                  "udt": {
                    "name": "Report"
                  }
                }
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Releases locked fees for a specific strategy.\\n\\n# Arguments\\n* `e` - The environment reference.\\n* `strategy` - The address of the strategy for which to release fees.\\n* `amount` - The amount of fees to release.\\n\\n# Returns\\n* `Result<Report, ContractError>` - A report of the released fees or a `ContractError` if the operation fails.",
      "name": "release_fees",
      "inputs": [
        {
          "doc": "",
          "name": "strategy",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "udt": {
                "name": "Report"
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Distributes the locked fees for all assets and their strategies.\\n\\nThis function iterates through each asset and its strategies, calculating the fees to be distributed\\nto the vault fee receiver and the DeFindex protocol fee receiver based on their respective fee rates.\\nIt ensures proper authorization and validation checks before proceeding with the distribution.\\n\\n# Arguments\\n* `e` - The environment reference.\\n* `caller` - The address initiating the fee distribution.\\n\\n# Returns\\n* `Result<Vec<(Address, i128)>, ContractError>` - A vector of tuples with asset addresses and the total distributed fee amounts.",
      "name": "distribute_fees",
      "inputs": [
        {
          "doc": "",
          "name": "caller",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": {
                  "tuple": {
                    "value_types": [
                      "address",
                      "i128"
                    ]
                  }
                }
              }
            },
            "error_type": {
              "udt": {
                "name": "ContractError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "Strategy",
      "fields": [
        {
          "doc": "",
          "name": "address",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "name",
          "type_": "string"
        },
        {
          "doc": "",
          "name": "paused",
          "type_": "bool"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "AssetStrategySet",
      "fields": [
        {
          "doc": "",
          "name": "address",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "strategies",
          "type_": {
            "vec": {
              "element_type": {
                "udt": {
                  "name": "Strategy"
                }
              }
            }
          }
        }
      ]
    }
  },
  {
    "udt_error_enum_v0": {
      "doc": "",
      "lib": "",
      "name": "StrategyError",
      "cases": [
        {
          "doc": "",
          "name": "NotInitialized",
          "value": 401
        },
        {
          "doc": "",
          "name": "NegativeNotAllowed",
          "value": 410
        },
        {
          "doc": "",
          "name": "InvalidArgument",
          "value": 411
        },
        {
          "doc": "",
          "name": "InsufficientBalance",
          "value": 412
        },
        {
          "doc": "",
          "name": "UnderflowOverflow",
          "value": 413
        },
        {
          "doc": "",
          "name": "ArithmeticError",
          "value": 414
        },
        {
          "doc": "",
          "name": "DivisionByZero",
          "value": 415
        },
        {
          "doc": "",
          "name": "InvalidSharesMinted",
          "value": 416
        },
        {
          "doc": "",
          "name": "OnlyPositiveAmountAllowed",
          "value": 417
        },
        {
          "doc": "",
          "name": "NotAuthorized",
          "value": 418
        },
        {
          "doc": "",
          "name": "ProtocolAddressNotFound",
          "value": 420
        },
        {
          "doc": "",
          "name": "DeadlineExpired",
          "value": 421
        },
        {
          "doc": "",
          "name": "ExternalError",
          "value": 422
        },
        {
          "doc": "",
          "name": "SoroswapPairError",
          "value": 423
        },
        {
          "doc": "",
          "name": "AmountBelowMinDust",
          "value": 451
        },
        {
          "doc": "",
          "name": "UnderlyingAmountBelowMin",
          "value": 452
        },
        {
          "doc": "",
          "name": "BTokensAmountBelowMin",
          "value": 453
        },
        {
          "doc": "",
          "name": "InternalSwapError",
          "value": 454
        },
        {
          "doc": "",
          "name": "SupplyNotFound",
          "value": 455
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "DepositEvent",
      "fields": [
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "HarvestEvent",
      "fields": [
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "WithdrawEvent",
      "fields": [
        {
          "doc": "",
          "name": "amount",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "from",
          "type_": "address"
        }
      ]
    }
  },
  {
    "udt_struct_v0": {
      "doc": "",
      "lib": "",
      "name": "TokenMetadata",
      "fields": [
        {
          "doc": "",
          "name": "decimal",
          "type_": "u32"
        },
        {
          "doc": "",
          "name": "name",
          "type_": "string"
        },
        {
          "doc": "",
          "name": "symbol",
          "type_": "string"
        }
      ]
    }
  },
  {
    "udt_error_enum_v0": {
      "doc": "",
      "lib": "",
      "name": "SoroswapLibraryError",
      "cases": [
        {
          "doc": "SoroswapLibrary: insufficient amount",
          "name": "InsufficientAmount",
          "value": 301
        },
        {
          "doc": "SoroswapLibrary: insufficient liquidity",
          "name": "InsufficientLiquidity",
          "value": 302
        },
        {
          "doc": "SoroswapLibrary: insufficient input amount",
          "name": "InsufficientInputAmount",
          "value": 303
        },
        {
          "doc": "SoroswapLibrary: insufficient output amount",
          "name": "InsufficientOutputAmount",
          "value": 304
        },
        {
          "doc": "SoroswapLibrary: invalid path",
          "name": "InvalidPath",
          "value": 305
        },
        {
          "doc": "SoroswapLibrary: token_a and token_b have identical addresses",
          "name": "SortIdenticalTokens",
          "value": 306
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Sorts two token addresses in a consistent order.\\n\\n# Arguments\\n\\n* `token_a` - The address of the first token.\\n* `token_b` - The address of the second token.\\n\\n# Returns\\n\\nReturns `Result<(Address, Address), SoroswapLibraryError>` where `Ok` contains a tuple with the sorted token addresses, and `Err` indicates an error such as identical tokens.",
      "name": "sort_tokens",
      "inputs": [
        {
          "doc": "",
          "name": "token_a",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_b",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": [
                  "address",
                  "address"
                ]
              }
            },
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Calculates the deterministic address for a pair without making any external calls.\\ncheck <https://github.com/paltalabs/deterministic-address-soroban>\\n\\n# Arguments\\n\\n* `e` - The environment.\\n* `factory` - The factory address.\\n* `token_a` - The address of the first token.\\n* `token_b` - The address of the second token.\\n\\n# Returns\\n\\nReturns `Result<Address, SoroswapLibraryError>` where `Ok` contains the deterministic address for the pair, and `Err` indicates an error such as identical tokens or an issue with sorting.",
      "name": "pair_for",
      "inputs": [
        {
          "doc": "",
          "name": "factory",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_a",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_b",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": "address",
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Fetches and sorts the reserves for a pair of tokens using the factory address.\\n\\n# Arguments\\n\\n* `e` - The environment.\\n* `factory` - The factory address.\\n* `token_a` - The address of the first token.\\n* `token_b` - The address of the second token.\\n\\n# Returns\\n\\nReturns `Result<(i128, i128), SoroswapLibraryError>` where `Ok` contains a tuple of sorted reserves, and `Err` indicates an error such as identical tokens or an issue with sorting.",
      "name": "get_reserves_with_factory",
      "inputs": [
        {
          "doc": "",
          "name": "factory",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_a",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_b",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": [
                  "i128",
                  "i128"
                ]
              }
            },
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Fetches and sorts the reserves for a pair of tokens using the pair address.\\n\\n# Arguments\\n\\n* `e` - The environment.\\n* `pair` - The pair address.\\n* `token_a` - The address of the first token.\\n* `token_b` - The address of the second token.\\n\\n# Returns\\n\\nReturns `Result<(i128, i128), SoroswapLibraryError>` where `Ok` contains a tuple of sorted reserves, and `Err` indicates an error such as identical tokens or an issue with sorting.",
      "name": "get_reserves_with_pair",
      "inputs": [
        {
          "doc": "",
          "name": "pair",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_a",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "token_b",
          "type_": "address"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "tuple": {
                "value_types": [
                  "i128",
                  "i128"
                ]
              }
            },
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset.\\n\\n# Arguments\\n\\n* `amount_a` - The amount of the first asset.\\n* `reserve_a` - Reserves of the first asset in the pair.\\n* `reserve_b` - Reserves of the second asset in the pair.\\n\\n# Returns\\n\\nReturns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated equivalent amount, and `Err` indicates an error such as insufficient amount or liquidity",
      "name": "quote",
      "inputs": [
        {
          "doc": "",
          "name": "amount_a",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_a",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_b",
          "type_": "i128"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": "i128",
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset.\\n\\n# Arguments\\n\\n* `amount_in` - The input amount of the asset.\\n* `reserve_in` - Reserves of the input asset in the pair.\\n* `reserve_out` - Reserves of the output asset in the pair.\\n\\n# Returns\\n\\nReturns `Result<i128, SoroswapLibraryError>` where `Ok` contains the calculated maximum output amount, and `Err` indicates an error such as insufficient input amount or liquidity.",
      "name": "get_amount_out",
      "inputs": [
        {
          "doc": "",
          "name": "amount_in",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_in",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_out",
          "type_": "i128"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": "i128",
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Given an output amount of an asset and pair reserves, returns a required input amount of the other asset.\\n\\n# Arguments\\n\\n* `amount_out` - The output amount of the asset.\\n* `reserve_in` - Reserves of the input asset in the pair.\\n* `reserve_out` - Reserves of the output asset in the pair.\\n\\n# Returns\\n\\nReturns `Result<i128, SoroswapLibraryError>` where `Ok` contains the required input amount, and `Err` indicates an error such as insufficient output amount or liquidity.",
      "name": "get_amount_in",
      "inputs": [
        {
          "doc": "",
          "name": "amount_out",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_in",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "reserve_out",
          "type_": "i128"
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": "i128",
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Performs chained get_amount_out calculations on any number of pairs.\\n\\n# Arguments\\n\\n* `e` - The environment.\\n* `factory` - The factory address.\\n* `amount_in` - The input amount.\\n* `path` - Vector of token addresses representing the path.\\n\\n# Returns\\n\\nReturns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.",
      "name": "get_amounts_out",
      "inputs": [
        {
          "doc": "",
          "name": "factory",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount_in",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "path",
          "type_": {
            "vec": {
              "element_type": "address"
            }
          }
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": "i128"
              }
            },
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  },
  {
    "function_v0": {
      "doc": "Performs chained get_amount_in calculations on any number of pairs.\\n\\n# Arguments\\n\\n* `e` - The environment.\\n* `factory` - The factory address.\\n* `amount_out` - The output amount.\\n* `path` - Vector of token addresses representing the path.\\n\\n# Returns\\n\\nReturns `Result<Vec<i128>, SoroswapLibraryError>` where `Ok` contains a vector of calculated amounts, and `Err` indicates an error such as an invalid path.",
      "name": "get_amounts_in",
      "inputs": [
        {
          "doc": "",
          "name": "factory",
          "type_": "address"
        },
        {
          "doc": "",
          "name": "amount_out",
          "type_": "i128"
        },
        {
          "doc": "",
          "name": "path",
          "type_": {
            "vec": {
              "element_type": "address"
            }
          }
        }
      ],
      "outputs": [
        {
          "result": {
            "ok_type": {
              "vec": {
                "element_type": "i128"
              }
            },
            "error_type": {
              "udt": {
                "name": "SoroswapLibraryError"
              }
            }
          }
        }
      ]
    }
  }
]